import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { Injectable, NgModule, Directive, Input, Host, Self, Optional, ElementRef, ContentChild, Component, EventEmitter, Output, ContentChildren, HostBinding, forwardRef, defineInjectable } from '@angular/core';
import { IonContent } from '@ionic/angular';
import { SuperTabs } from '@ionic-super-tabs/angular';
import $ from 'jquery';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavService {
    constructor() {
        this.data = [];
        this.names = [];
        this.tabnames = [];
    }
    /**
     * @return {?}
     */
    requestName() {
        /** @type {?} */
        let name = 'page' + this.names.length;
        this.names.push(name);
        return name;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    requestTabName(name) {
        if (!this.tabnames[name])
            this.tabnames[name] = [];
        /** @type {?} */
        let tabname = name + 'tab' + this.tabnames[name].length;
        this.tabnames[name].push(tabname);
        return tabname;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    initiate(name) {
        /** @type {?} */
        let names = [];
        for (let key in this.data) {
            if (this.data[key].parent == name)
                names.push(key);
        }
        for (let name of names) {
            this.initiate2(name);
        }
        if (names.length == 0)
            this.initiate2(name);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    initiate2(name) {
        if (!(this.data[name] && (this.data[name].parent && this.data[this.data[name].parent].tabscontent && this.data[name].content && this.data[this.data[name].parent].header) || (!this.data[name].parent && this.data[name].content && this.data[name].header)))
            return false;
        /** @type {?} */
        let parent = this.data[name].parent;
        /** @type {?} */
        let content = this.data[name].content;
        /** @type {?} */
        let contentElem = this.data[name].contentElem;
        if (this.data[name].scrollTop == null)
            this.data[name].scrollTop = 0;
        if (this.data[name].lastscroll == null)
            this.data[name].lastscroll = 0;
        if (this.data[name].direction == null)
            this.data[name].direction = '';
        if (this.data[name].tapping == null)
            this.data[name].tapping = false;
        content.scrollEvents = true;
        if (!parent) {
            /** @type {?} */
            let header = this.data[name].header;
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.data[name].navheight = this.data[name].header.nativeElement.offsetHeight;
                /** @type {?} */
                let scrollContent = contentElem.nativeElement.shadowRoot.querySelector('.inner-scroll');
                this.data[name].paddingTop = parseInt(window.getComputedStyle(scrollContent)['padding-top'], 10);
                content.ionScroll.subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    if (e.detail.scrollTop == 0) {
                        scrollContent.style.top = null;
                        scrollContent.style.paddingTop = this.data[name].paddingTop + 'px';
                    }
                    else {
                        scrollContent.style.top = '-' + this.data[name].navheight + 'px';
                        scrollContent.style.paddingTop = this.data[name].paddingTop + this.data[name].navheight + 'px';
                    }
                    if (scrollContent.scrollHeight > (scrollContent.clientHeight + 100)) {
                        this.data[name].scrolling = true;
                        /** @type {?} */
                        let x = this.data[name].lastscroll - e.detail.scrollTop;
                        this.data[name].direction = x > 0 ? 'up' : 'down';
                        this.data[name].lastscroll = e.detail.scrollTop;
                        this.data[name].scrollTop = this.data[name].scrollTop - x;
                        if (this.data[name].scrollTop > this.data[name].navheight)
                            this.data[name].scrollTop = this.data[name].navheight;
                        if (this.data[name].scrollTop < 0)
                            this.data[name].scrollTop = 0;
                        header.nativeElement.style.transform = 'translate3d(0, ' + -this.data[name].scrollTop + 'px, 0)';
                    }
                }));
                content.ionScrollEnd.subscribe((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        //catch the last tick
                        if (scrollContent.scrollTop == 0) {
                            scrollContent.style.top = null;
                            scrollContent.style.paddingTop = this.data[name].paddingTop + 'px';
                        }
                        this.data[name].scrolling = false;
                        this.c(name);
                    }), 10);
                }));
            }), 100);
            contentElem.nativeElement.addEventListener('touchend', (/**
             * @return {?}
             */
            () => {
                this.data[name].tapping = false;
                this.c(name);
            }));
            contentElem.nativeElement.addEventListener('touchstart', (/**
             * @return {?}
             */
            () => this.data[name].tapping = true));
        }
        else if (parent) {
            /** @type {?} */
            let header = this.data[parent].header;
            /** @type {?} */
            let tabscontentElem = this.data[parent].tabscontentElem;
            /** @type {?} */
            let supertabsToolbar = tabscontentElem.nativeElement.querySelector('super-tabs-toolbar');
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.data[parent].tabscontentHeight = tabscontentElem.nativeElement.scrollHeight;
                /** @type {?} */
                let scrollContent = contentElem.nativeElement.shadowRoot.querySelector('.inner-scroll');
                /** @type {?} */
                let tabsscrollContent = this.data[parent].tabscontentElem.nativeElement.shadowRoot.querySelector('.inner-scroll');
                if (scrollContent.scrollHeight > (scrollContent.clientHeight + 100)) {
                    this.data[name].navheight = this.data[parent].header.nativeElement.offsetHeight;
                    this.data[name].paddingTop = parseInt(window.getComputedStyle(scrollContent)['padding-top'], 10);
                }
                content.ionScroll.subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    if (this.data[name].tapping && scrollContent.scrollHeight > (scrollContent.clientHeight + 100)) {
                        if (e.detail.scrollTop == 0) {
                            supertabsToolbar.style.position = 'static';
                            scrollContent.style.paddingTop = this.data[name].paddingTop + 'px';
                            tabscontentElem.nativeElement.style.top = null;
                            tabsscrollContent.style.height = this.data[parent].tabscontentHeight + 'px';
                            tabscontentElem.nativeElement.style.top = null;
                        }
                        else {
                            /** @type {?} */
                            let s = e.detail.scrollTop;
                            supertabsToolbar.style.position = 'absolute';
                            supertabsToolbar.style.top = this.data[name].navheight + 'px';
                            tabsscrollContent.style.height = (this.data[parent].tabscontentHeight + this.data[name].navheight) + 'px';
                            tabscontentElem.nativeElement.style.top = '-' + this.data[name].navheight + 'px';
                            scrollContent.style.paddingTop = this.data[name].paddingTop + supertabsToolbar.clientHeight + this.data[name].navheight + 'px';
                            scrollContent.scrollTop = s;
                        }
                    }
                    this.data[name].scrolling = true;
                    /** @type {?} */
                    let x = this.data[name].lastscroll - e.detail.scrollTop;
                    this.data[name].direction = x > 0 ? 'up' : 'down';
                    this.data[name].lastscroll = e.detail.scrollTop;
                    this.data[name].scrollTop = this.data[name].scrollTop - x;
                    if (this.data[name].scrollTop > this.data[name].navheight)
                        this.data[name].scrollTop = this.data[name].navheight;
                    if (this.data[name].scrollTop < 0)
                        this.data[name].scrollTop = 0;
                    header.nativeElement.style.transform = 'translate3d(0, ' + -this.data[name].scrollTop + 'px, 0)';
                    supertabsToolbar.style.transform = 'translate3d(0, ' + -this.data[name].scrollTop + 'px, 0)';
                }));
                content.ionScrollEnd.subscribe((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        //catch the last tick
                        if (scrollContent.scrollTop == 0) {
                            supertabsToolbar.style.position = 'static';
                            scrollContent.style.paddingTop = this.data[name].paddingTop + 'px';
                            tabscontentElem.nativeElement.style.top = null;
                            tabsscrollContent.style.height = this.data[parent].tabscontentHeight + 'px';
                            tabscontentElem.nativeElement.style.top = null;
                        }
                        this.data[name].scrolling = false;
                        this.c(name);
                    }), 10);
                }));
            }), 100);
            contentElem.nativeElement.addEventListener('touchend', (/**
             * @return {?}
             */
            () => {
                this.data[name].tapping = false;
                this.c(name);
            }));
            contentElem.nativeElement.addEventListener('touchstart', (/**
             * @return {?}
             */
            () => this.data[name].tapping = true));
        }
    }
    /**
     * @private
     * @param {?} name
     * @return {?}
     */
    c(name) {
        if (this.data[name].tapping || this.data[name].scrolling)
            return false;
        if (this.data[name].scrollTop == 0 || this.data[name].scrollTop == this.data[name].navheight)
            return false;
        /** @type {?} */
        let content = this.data[name].content;
        /** @type {?} */
        let scrollTopTemp = this.data[name].scrollTop;
        if (this.data[name].direction == 'down') {
            if (this.data[name].scrollTop < this.data[name].navheight) {
                content.scrollByPoint(0, (this.data[name].navheight - scrollTopTemp), (this.data[name].navheight - scrollTopTemp) * 6);
            }
        }
        else if (this.data[name].direction == 'up') {
            if (this.data[name].scrollTop < this.data[name].navheight) {
                content.scrollByPoint(0, -scrollTopTemp, scrollTopTemp * 6);
            }
        }
    }
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    resetTabs(parent, name) {
        /** @type {?} */
        let header = this.data[parent].header;
        /** @type {?} */
        let tabscontentElem = this.data[parent].tabscontentElem;
        /** @type {?} */
        let supertabsToolbar = tabscontentElem.nativeElement.querySelector('super-tabs-toolbar');
        /** @type {?} */
        let tabsscrollContent = this.data[parent].tabscontentElem.nativeElement.shadowRoot.querySelector('.inner-scroll');
        /** @type {?} */
        let scrollContent = this.data[name].contentElem.nativeElement.shadowRoot.querySelector('.inner-scroll');
        scrollContent.scrollTop = scrollContent.scrollTop - this.data[name].scrollTop;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (scrollContent.scrollTop == 0) {
                supertabsToolbar.style.position = 'static';
                scrollContent.style.paddingTop = this.data[name].paddingTop + 'px';
                tabscontentElem.nativeElement.style.top = null;
                tabsscrollContent.style.height = this.data[parent].tabscontentHeight + 'px';
                tabscontentElem.nativeElement.style.top = null;
            }
            else {
                /** @type {?} */
                let s = scrollContent.scrollTop;
                supertabsToolbar.style.position = 'absolute';
                supertabsToolbar.style.top = this.data[name].navheight + 'px';
                tabsscrollContent.style.height = (this.data[parent].tabscontentHeight + this.data[name].navheight) + 'px';
                tabscontentElem.nativeElement.style.top = '-' + this.data[name].navheight + 'px';
                scrollContent.style.paddingTop = this.data[name].paddingTop + supertabsToolbar.clientHeight + this.data[name].navheight + 'px';
                scrollContent.scrollTop = s;
            }
            header.nativeElement.style.transform = null;
            supertabsToolbar.style.transform = null;
        }), 20);
    }
}
HidenavService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
HidenavService.ctorParameters = () => [];
/** @nocollapse */ HidenavService.ngInjectableDef = defineInjectable({ factory: function HidenavService_Factory() { return new HidenavService(); }, token: HidenavService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavTabscontentDirective {
    /**
     * @param {?} el
     * @param {?} contentElem
     * @param {?} globals
     */
    constructor(el, contentElem, globals) {
        this.el = el;
        this.contentElem = contentElem;
        this.globals = globals;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.name = this.globals.requestName();
        this.contentElem.nativeElement.setAttribute('hidenav-tabscontent', this.name);
        $('[hidenav-header]', $(this.contentElem.nativeElement).parents().get().find((/**
         * @param {?} itm
         * @return {?}
         */
        itm => $(itm).find('[hidenav-header]').length))).attr('hidenav-header', this.name);
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            this.globals.data[this.name].tabscontent = this.el;
            this.globals.data[this.name].tabscontentElem = this.contentElem;
            this.globals.initiate(this.name);
            if (this.supertabs) {
                this.supertabs.tabChange.subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                e => {
                    if (e.detail.changed == true) {
                        /** @type {?} */
                        let i = e.detail.index;
                        /** @type {?} */
                        let tabs = this.contentElem.nativeElement.querySelectorAll('super-tab');
                        /** @type {?} */
                        let results = [];
                        for (let tab of tabs) {
                            /** @type {?} */
                            let cont = tab.querySelector('ion-content');
                            if (cont.attributes['hidenav-content'])
                                results.push(cont.attributes['hidenav-content'].nodeValue);
                            else
                                results.push(null);
                        }
                        if (results[i] != null) {
                            this.globals.resetTabs(this.name, results[i]);
                        }
                    }
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.name) {
            delete this.globals.data[this.name].tabscontent;
        }
    }
}
HidenavTabscontentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hidenav-tabscontent]'
            },] }
];
HidenavTabscontentDirective.ctorParameters = () => [
    { type: IonContent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: ElementRef },
    { type: HidenavService }
];
HidenavTabscontentDirective.propDecorators = {
    supertabs: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => SuperTabs)),] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavContentDirective {
    /**
     * @param {?} el
     * @param {?} contentElem
     * @param {?} globals
     */
    constructor(el, contentElem, globals) {
        this.el = el;
        this.contentElem = contentElem;
        this.globals = globals;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.contentElem.nativeElement.hasAttribute('hidenav-tabspage')) {
            this.name = this.globals.requestName();
            $(this.contentElem.nativeElement).attr('hidenav-content', this.name);
            $('[hidenav-header]', $(this.contentElem.nativeElement).parents().get().find((/**
             * @param {?} itm
             * @return {?}
             */
            itm => $(itm).find('[hidenav-header]').length))).attr('hidenav-header', this.name);
            this.start();
        }
        else {
            /** @type {?} */
            let counter = 0;
            /** @type {?} */
            let int = setInterval((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                let x = $(this.contentElem.nativeElement).closest('[hidenav-tabscontent]').attr('hidenav-tabscontent');
                counter++;
                if (x && x.length > 0) {
                    this.parent = $(this.contentElem.nativeElement).closest('[hidenav-tabscontent]').attr('hidenav-tabscontent');
                    this.name = this.globals.requestTabName(this.parent);
                    $(this.contentElem.nativeElement).attr('hidenav-content', this.name);
                    $(this.contentElem.nativeElement).attr('hidenav-tabspage', this.parent);
                    this.start();
                    clearInterval(int);
                }
                else if (counter > 50) {
                    clearInterval(int);
                }
            }), 50);
        }
    }
    /**
     * @return {?}
     */
    start() {
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            this.globals.data[this.name].content = this.el;
            this.globals.data[this.name].contentElem = this.contentElem;
            if (this.parent)
                this.globals.data[this.name].parent = this.parent;
            this.globals.initiate(this.name);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.name) {
            delete this.globals.data[this.name].content;
        }
    }
}
HidenavContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hidenav-content]'
            },] }
];
HidenavContentDirective.ctorParameters = () => [
    { type: IonContent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: ElementRef },
    { type: HidenavService }
];
HidenavContentDirective.propDecorators = {
    hntb: [{ type: Input, args: ['hidenav-tabspage',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavHeaderDirective {
    /**
     * @param {?} el
     * @param {?} globals
     */
    constructor(el, globals) {
        this.el = el;
        this.globals = globals;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const observer = new MutationObserver((/**
         * @param {?} mutations
         * @return {?}
         */
        (mutations) => {
            mutations.forEach((/**
             * @return {?}
             */
            () => {
                if (this.el.nativeElement.getAttribute('hidenav-header').length > 0) {
                    this.name = this.el.nativeElement.getAttribute('hidenav-header');
                    this.start();
                    observer.disconnect();
                }
            }));
        }));
        observer.observe(this.el.nativeElement, {
            attributes: true,
        });
    }
    /**
     * @return {?}
     */
    start() {
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            if (this.globals.data[this.name].header != null)
                return false;
            this.globals.data[this.name].header = this.el;
            this.globals.initiate(this.name);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.name) {
            delete this.globals.data[this.name].header;
        }
    }
}
HidenavHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hidenav-header]'
            },] }
];
HidenavHeaderDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: HidenavService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavShService {
    constructor() {
        this.data = [];
        this.mode = 'ios';
        this.names = [];
        this.tabnames = [];
        this.scroll = new Subject();
    }
    /**
     * @return {?}
     */
    requestName() {
        /** @type {?} */
        let name = 'page' + this.names.length;
        this.names.push(name);
        return name;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    requestTabName(name) {
        if (!this.tabnames[name])
            this.tabnames[name] = [];
        /** @type {?} */
        let tabname = name + 'tab' + this.tabnames[name].length;
        this.tabnames[name].push(tabname);
        return tabname;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    initiate(name) {
        /** @type {?} */
        let names = [];
        for (let key in this.data) {
            if (this.data[key].parent == name)
                names.push(key);
        }
        for (let name of names) {
            this.initiate2(name);
        }
        if (names.length == 0)
            this.initiate2(name);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    initiate2(name) {
        if (!(this.data[name] && (this.data[name].parent && this.data[this.data[name].parent] && this.data[this.data[name].parent].tabscontent && this.data[name].content && this.data[this.data[name].parent].header) || (!this.data[name].parent && this.data[name].content && this.data[name].header)))
            return false;
        /** @type {?} */
        let parent = this.data[name].parent;
        /** @type {?} */
        let content = this.data[name].content;
        if (this.data[name].lastscroll == null)
            this.data[name].lastscroll = 0;
        if (this.data[name].guardEvents == null)
            this.data[name].guardEvents = true;
        content.scrollEvents = true;
        if (!parent) {
            /** @type {?} */
            let header = this.data[name].header;
            if (this.data[name].static) {
                this.data[name].static.forEach((/**
                 * @param {?} el
                 * @return {?}
                 */
                el => {
                    el.nativeElement.style.position = 'absolute';
                    el.nativeElement.style.zIndex = 102;
                }));
            }
            if (header) {
                /** @type {?} */
                let parentElem = header.nativeElement.parentNode;
                /** @type {?} */
                let elem = header.nativeElement;
                if (parentElem.getAttribute('init-expanded') == 'true')
                    this.data[name].initExpanded = true;
                /** @type {?} */
                let notchHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--ion-safe-area-top"), 10);
                this.data[name].shrinkexpandheaderHeight = parseInt(parentElem.getAttribute('header-height'), 10) + notchHeight;
                this.data[name].opacityFactor = parseInt(parentElem.getAttribute('opacity-factor'), 10);
                this.data[name].opacityColor = parentElem.getAttribute('opacity-color');
                this.data[name].blurFactor = parseInt(parentElem.getAttribute('blur-factor'), 10);
                parentElem.style.height = this.data[name].shrinkexpandheaderHeight + 'px';
                parentElem.style.overflow = 'hidden';
                parentElem.style.position = 'absolute';
                elem.style.position = 'absolute';
                parentElem.style.width = '100%';
                elem.style.width = '100%';
                this.waitforelem(name, 'this.data[name].header.nativeElement.scrollHeight', 'proceedShrinkExpand');
            }
        }
        else if (parent) {
            /** @type {?} */
            let header = this.data[parent].header;
            /** @type {?} */
            let tabscontentElem = this.data[parent].tabscontentElem;
            if (this.data[parent].static) {
                this.data[parent].static.forEach((/**
                 * @param {?} el
                 * @return {?}
                 */
                el => {
                    el.nativeElement.style.position = 'absolute';
                    el.nativeElement.style.zIndex = 102;
                }));
            }
            if (header) {
                /** @type {?} */
                let supertabsToolbar = tabscontentElem.nativeElement.querySelector('super-tabs-toolbar');
                /** @type {?} */
                let parentElem = header.nativeElement.parentNode;
                /** @type {?} */
                let elem = header.nativeElement;
                if (parentElem.getAttribute('init-expanded') == 'true')
                    this.data[name].initExpanded = true;
                if (parentElem.getAttribute('preserve-header') == 'true') {
                    this.data[name].preserveHeader = true;
                    this.data[parent].preserveHeader = true;
                }
                /** @type {?} */
                let notchHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--ion-safe-area-top"), 10);
                this.data[name].shrinkexpandheaderHeight = parseInt(parentElem.getAttribute('header-height'), 10) + notchHeight;
                this.data[name].opacityFactor = parseInt(parentElem.getAttribute('opacity-factor'), 10);
                this.data[name].opacityColor = elem.getAttribute('opacity-color');
                this.data[name].blurFactor = parseInt(parentElem.getAttribute('blur-factor'), 10);
                parentElem.style.height = this.data[name].shrinkexpandheaderHeight + 'px';
                parentElem.style.overflow = 'hidden';
                parentElem.style.position = 'absolute';
                elem.style.position = 'absolute';
                parentElem.style.width = '100%';
                elem.style.width = '100%';
                supertabsToolbar.style.position = 'absolute';
                supertabsToolbar.style.transform = 'translate3d(0, ' + this.data[name].shrinkexpandheaderHeight + 'px, 0)';
                parentElem.style.zIndex = 101;
                this.waitforelemTabs(name, 'this.data[this.data[name].parent].header.nativeElement.scrollHeight', 'this.data[this.data[name].parent].tabscontentElem.nativeElement.querySelector(\'super-tabs-toolbar\').clientHeight', 'proceedShrinkExpandTabs');
            }
        }
    }
    /**
     * @param {?} name
     * @param {?} evaluate
     * @param {?} func
     * @return {?}
     */
    waitforelem(name, evaluate, func) {
        /** @type {?} */
        let x = eval(evaluate);
        if (!{ x } || x < this.data[name].shrinkexpandheaderHeight) {
            window.requestAnimationFrame(this.waitforelem.bind(this, name, evaluate, func));
        }
        else {
            this[func](name);
        }
    }
    /**
     * @param {?} name
     * @param {?} evaluate
     * @param {?} evaluate2
     * @param {?} func
     * @return {?}
     */
    waitforelemTabs(name, evaluate, evaluate2, func) {
        /** @type {?} */
        let x = eval(evaluate);
        /** @type {?} */
        let y = eval(evaluate2);
        if (!{ x } || x < this.data[name].shrinkexpandheaderHeight || !{ y } || y == 0) {
            window.requestAnimationFrame(this.waitforelemTabs.bind(this, name, evaluate, evaluate2, func));
        }
        else {
            this[func](name);
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    proceedShrinkExpand(name) {
        /** @type {?} */
        let parentElem = this.data[name].header.nativeElement.parentNode;
        /** @type {?} */
        let elem = this.data[name].header.nativeElement;
        /** @type {?} */
        let overlay = this.data[name].header.nativeElement.parentNode.querySelector('.overlay');
        if (this.data[name].opacityColor) {
            overlay.style.setProperty('--color', this.data[name].opacityColor);
        }
        if (this.data[name].opacityFactor > 0) {
            //angular decides that opacity is bad and changes it to alpha which doesn't work lol
            overlay.style.setProperty('filter', 'opacity(var(--opacity))');
            overlay.style.setProperty('--opacity', this.data[name].opacityFactor / 10);
        }
        if (this.data[name].blurFactor > 0) {
            elem.style.setProperty('filter', 'blur(var(--blur))');
            elem.style.setProperty('--blur', this.data[name].blurFactor / 10);
        }
        this.data[name].shrinkexpandHeight = this.data[name].shrinkexpandheaderHeight;
        this.data[name].shrinkexpandHeight = this.data[name].header.nativeElement.scrollHeight;
        elem.style.transform = 'translate3d(0, ' + -((this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight) / 2) + 'px, 0)';
        this.data[name].content.getScrollElement().then((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            this.data[name].contentElem = res;
            this.data[name].paddingTop = parseInt(window.getComputedStyle(this.data[name].contentElem)['padding-top'], 10);
            this.data[name].contentElem.style.paddingTop = (this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
            //this.data[name].contentElem.style.marginTop = this.data[name].shrinkexpandheaderHeight + 'px';
            /** @type {?} */
            let elemPad = document.createElement('div');
            elemPad.style.cssText = 'background:rgba(0,0,0,0)';
            /** @type {?} */
            let x = this.data[name].contentElem.scrollHeight + (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight);
            //experimental height
            elemPad.style.height = x + 'px';
            setTimeout((/**
             * @return {?}
             */
            () => {
                //check if height is still ok and adjust if not
                this.data[name].elemPadHeight = Math.max(0, (x - (this.data[name].contentElem.scrollHeight - this.data[name].contentElem.offsetHeight) + (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight)));
                elemPad.style.height = this.data[name].elemPadHeight + 'px';
            }), 100);
            this.data[name].contentElem.appendChild(elemPad);
            /** @type {?} */
            let scrollDist = this.data[name].initExpanded ? 2 : (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight);
            this.data[name].content.scrollByPoint(0, scrollDist, 0).then((/**
             * @return {?}
             */
            () => {
                this.data[name].contentHeight = this.data[name].contentEl.nativeElement.clientHeight;
                this.data[name].content.scrollEvents = true;
                this.data[name].content.ionScroll.subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                e => {
                    if (e.detail.scrollTop == 0) {
                        this.data[name].contentElem.style.paddingTop = 0;
                        this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight - this.data[name].shrinkexpandHeight) + 'px';
                        this.data[name].contentEl.nativeElement.style.top = (this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
                        elemPad.style.height = (this.data[name].elemPadHeight + this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
                    }
                    else {
                        /** @type {?} */
                        let s = e.detail.scrollTop;
                        this.data[name].contentElem.style.paddingTop = (this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
                        this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight + this.data[name].shrinkexpandHeight) + 'px';
                        this.data[name].contentEl.nativeElement.style.top = null;
                        this.data[name].contentElem.scrollTop = s;
                        elemPad.style.height = this.data[name].elemPadHeight + 'px';
                    }
                    if (this.data[name].initExpanded) {
                        this.data[name].content.scrollToPoint(0, 0, 0).then((/**
                         * @return {?}
                         */
                        () => {
                            this.data[name].initExpanded = false;
                        }));
                    }
                    if (this.data[name].initExpanded) {
                        this.data[name].content.scrollToPoint(0, 0, 0).then((/**
                         * @return {?}
                         */
                        () => {
                            this.data[name].initExpanded = false;
                        }));
                    }
                    /** @type {?} */
                    let height = Math.max(Math.min(this.data[name].shrinkexpandHeight, this.data[name].shrinkexpandHeight - e.detail.scrollTop), this.data[name].shrinkexpandheaderHeight);
                    elem.style.transform = 'translate3d(0, ' + -(Math.min((this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight) / 2, e.detail.scrollTop / 2)) + 'px, 0)';
                    parentElem.style.height = height + 'px';
                    /** @type {?} */
                    let scrollFactor = Math.min(e.detail.scrollTop / (this.data[name].shrinkexpandHeight / 2), 1);
                    if (scrollFactor >= 0) {
                        /** @type {?} */
                        let currentValOpacity = overlay.style.getPropertyValue('--opacity');
                        /** @type {?} */
                        let newValOpacity = this.data[name].opacityFactor / 10 * scrollFactor;
                        if (currentValOpacity != newValOpacity)
                            overlay.style.setProperty('--opacity', newValOpacity);
                        /** @type {?} */
                        let currentValBlur = elem.style.getPropertyValue('--blur');
                        /** @type {?} */
                        let newValBlur = (this.data[name].blurFactor * scrollFactor) + 'px';
                        if (currentValBlur != newValBlur)
                            elem.style.setProperty('--blur', newValBlur);
                    }
                    //event emitter
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.data[name].guardEvents = false;
                    }), 10);
                    if (this.data[name].lastscroll != height && !this.data[name].guardEvents) {
                        this.scroll.next({ name: this.data[name].parent ? this.data[name].parent : name, height: height });
                    }
                    this.data[name].lastscroll = height;
                    //
                }));
                //catch the last tick
                this.data[name].content.ionScrollEnd.subscribe((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        if (this.data[name].contentElem.scrollTop == 0) {
                            this.data[name].contentElem.style.paddingTop = 0;
                            this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight - this.data[name].shrinkexpandHeight) + 'px';
                            this.data[name].contentEl.nativeElement.style.top = (this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
                            elemPad.style.height = (this.data[name].elemPadHeight + this.data[name].shrinkexpandHeight + this.data[name].paddingTop) + 'px';
                        }
                    }), 10);
                }));
            }));
        }));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    proceedShrinkExpandTabs(name) {
        /** @type {?} */
        let parent = this.data[name].parent;
        /** @type {?} */
        let parentElem = this.data[parent].header.nativeElement.parentNode;
        /** @type {?} */
        let elem = this.data[parent].header.nativeElement;
        /** @type {?} */
        let tabscontentElem = this.data[parent].tabscontentElem;
        /** @type {?} */
        let supertabsToolbar = tabscontentElem.nativeElement.querySelector('super-tabs-toolbar');
        /** @type {?} */
        let overlay = this.data[parent].header.nativeElement.parentNode.querySelector('.overlay');
        if (this.data[name].opacityColor) {
            overlay.style.setProperty('--color', this.data[name].opacityColor);
        }
        if (this.data[name].opacityFactor > 0) {
            //angular decides that opacity is bad and changes it to alpha which doesn't work lol
            overlay.style.setProperty('filter', 'opacity(var(--opacity))');
            overlay.style.setProperty('--opacity', this.data[name].opacityFactor / 10);
        }
        if (this.data[name].blurFactor > 0) {
            elem.style.setProperty('filter', 'blur(var(--blur))');
            elem.style.setProperty('--blur', this.data[name].blurFactor / 10);
        }
        this.data[name].shrinkexpandHeight = this.data[name].shrinkexpandheaderHeight;
        this.data[name].shrinkexpandHeight = elem.scrollHeight;
        elem.style.transform = 'translate3d(0, ' + -((this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight) / 2) + 'px, 0)';
        this.data[name].content.getScrollElement().then((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            this.data[name].contentElem = res;
            this.data[name].paddingTop = parseInt(window.getComputedStyle(this.data[name].contentElem)['padding-top'], 10);
            this.data[name].contentElem.style.paddingTop = (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight + this.data[name].paddingTop) + 'px';
            this.data[name].contentElem.style.height = (this.data[parent].tabscontentElem.nativeElement.clientHeight) + 'px';
            //this.data[name].contentElem.style.marginTop = this.data[name].shrinkexpandheaderHeight + 'px';
            /** @type {?} */
            let elemPad = document.createElement('div');
            elemPad.style.cssText = 'background:rgba(0,0,0,0)';
            /** @type {?} */
            let x = this.data[name].contentElem.scrollHeight + (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight);
            //experimental height
            elemPad.style.height = x + 'px';
            setTimeout((/**
             * @return {?}
             */
            () => {
                //check if height is still ok and adjust if not
                this.data[name].elemPadHeight = Math.max(0, (x - (this.data[name].contentElem.scrollHeight - this.data[name].contentElem.offsetHeight) + (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight)));
                elemPad.style.height = this.data[name].elemPadHeight + 'px';
            }), 100);
            this.data[name].contentElem.appendChild(elemPad);
            /** @type {?} */
            let scrollDist = this.data[name].initExpanded ? 2 : (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight);
            this.data[name].content.scrollByPoint(0, scrollDist, 0).then((/**
             * @return {?}
             */
            () => {
                this.data[name].contentHeight = this.data[name].contentEl.nativeElement.clientHeight;
                this.data[name].content.scrollEvents = true;
                this.data[name].content.ionScroll.subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                e => {
                    if (e.detail.scrollTop == 0) {
                        this.data[name].contentElem.style.paddingTop = 0;
                        this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight - (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight)) + 'px';
                        this.data[name].contentEl.nativeElement.style.top = (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight + this.data[name].paddingTop) + 'px';
                        elemPad.style.height = (this.data[name].elemPadHeight + this.data[name].shrinkexpandHeight + this.data[name].paddingTop + supertabsToolbar.clientHeight) + 'px';
                    }
                    else {
                        /** @type {?} */
                        let s = e.detail.scrollTop;
                        this.data[name].contentElem.style.paddingTop = (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight + this.data[name].paddingTop) + 'px';
                        this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight + this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight) + 'px';
                        this.data[name].contentEl.nativeElement.style.top = null;
                        this.data[name].contentElem.scrollTop = s;
                        elemPad.style.height = this.data[name].elemPadHeight + 'px';
                    }
                    if (this.data[name].initExpanded) {
                        this.data[name].content.scrollToPoint(0, 0, 0).then((/**
                         * @return {?}
                         */
                        () => {
                            this.data[name].initExpanded = false;
                        }));
                    }
                    /** @type {?} */
                    let height = Math.max(Math.min(this.data[name].shrinkexpandHeight, this.data[name].shrinkexpandHeight - e.detail.scrollTop), this.data[name].shrinkexpandheaderHeight);
                    elem.style.transform = 'translate3d(0, ' + -(Math.min((this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight) / 2, e.detail.scrollTop / 2)) + 'px, 0)';
                    parentElem.style.height = height + 'px';
                    /** @type {?} */
                    let scrollFactor = Math.min(e.detail.scrollTop / (this.data[name].shrinkexpandHeight / 2), 1);
                    if (scrollFactor >= 0) {
                        /** @type {?} */
                        let currentValOpacity = overlay.style.getPropertyValue('--opacity');
                        /** @type {?} */
                        let newValOpacity = this.data[name].opacityFactor / 10 * scrollFactor;
                        if (currentValOpacity != newValOpacity)
                            overlay.style.setProperty('--opacity', newValOpacity);
                        /** @type {?} */
                        let currentValBlur = elem.style.getPropertyValue('--blur');
                        /** @type {?} */
                        let newValBlur = (this.data[name].blurFactor * scrollFactor) + 'px';
                        if (currentValBlur != newValBlur)
                            elem.style.setProperty('--blur', newValBlur);
                    }
                    supertabsToolbar.style.transform = 'translate3d(0, ' + height + 'px, 0)';
                    //event emitter
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.data[name].guardEvents = false;
                    }), 10);
                    if (this.data[name].lastscroll != height && !this.data[name].guardEvents) {
                        this.scroll.next({ name: this.data[name].parent ? this.data[name].parent : name, height: height });
                    }
                    this.data[name].lastscroll = height;
                    //
                }));
                //catch the last tick
                this.data[name].content.ionScrollEnd.subscribe((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        if (this.data[name].contentElem.scrollTop == 0) {
                            this.data[name].contentElem.style.paddingTop = 0;
                            this.data[name].contentEl.nativeElement.style.height = (this.data[name].contentHeight - (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight)) + 'px';
                            this.data[name].contentEl.nativeElement.style.top = (this.data[name].shrinkexpandHeight + supertabsToolbar.clientHeight + this.data[name].paddingTop) + 'px';
                            elemPad.style.height = (this.data[name].elemPadHeight + this.data[name].shrinkexpandHeight + this.data[name].paddingTop + supertabsToolbar.clientHeight) + 'px';
                        }
                    }), 10);
                }));
            }));
        }));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    resetContent(name) {
        if (!this.data[name].preserveHeader) {
            /** @type {?} */
            let parent = this.data[name].parent;
            /** @type {?} */
            let height = parseInt(this.data[parent].header.nativeElement.parentNode.style.height, 10);
            if (height <= this.data[name].shrinkexpandHeight && height > this.data[name].shrinkexpandheaderHeight || height == this.data[name].shrinkexpandheaderHeight && this.data[name].contentElem.scrollTop < (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight)) {
                this.data[name].contentElem.scrollTop = this.data[name].shrinkexpandHeight - height;
            }
        }
        else {
            /** @type {?} */
            let parent = this.data[name].parent;
            /** @type {?} */
            let parentElem = this.data[parent].header.nativeElement.parentNode;
            /** @type {?} */
            let elem = this.data[parent].header.nativeElement;
            /** @type {?} */
            let tabscontentElem = this.data[parent].tabscontentElem;
            /** @type {?} */
            let supertabsToolbar = tabscontentElem.nativeElement.querySelector('super-tabs-toolbar');
            /** @type {?} */
            let overlay = this.data[parent].header.nativeElement.parentNode.querySelector('.overlay');
            /** @type {?} */
            let height = Math.max(Math.min(this.data[name].shrinkexpandHeight, this.data[name].shrinkexpandHeight - this.data[name].contentElem.scrollTop), this.data[name].shrinkexpandheaderHeight);
            elem.style.transform = 'translate3d(0, ' + -(Math.min((this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight) / 2, this.data[name].contentElem.scrollTop / 2)) + 'px, 0)';
            parentElem.style.height = height + 'px';
            overlay.style.setProperty('--opacity', this.data[name].opacityFactor / 10 * Math.min(this.data[name].contentElem.scrollTop / (this.data[name].shrinkexpandHeight / 2), 1));
            elem.style.setProperty('--blur', (this.data[name].blurFactor * Math.min(this.data[name].contentElem.scrollTop / (this.data[name].shrinkexpandHeight / 2), 1)) + 'px');
            supertabsToolbar.style.transform = 'translate3d(0, ' + height + 'px, 0)';
            this.scroll.next({ name: this.data[name].parent, height: height });
        }
    }
    /**
     * @param {?} parent
     * @return {?}
     */
    findCurrentTab(parent) {
        /** @type {?} */
        let i = this.data[parent].supertabs.activeTabIndex;
        /** @type {?} */
        let tabs = this.data[parent].tabscontentElem.nativeElement.querySelectorAll('super-tab');
        /** @type {?} */
        let results = [];
        for (let tab of tabs) {
            /** @type {?} */
            let cont = tab.querySelector('ion-content');
            if (cont.attributes['hidenav-sh-content'])
                results.push(cont.attributes['hidenav-sh-content'].nodeValue);
            else
                results.push(null);
        }
        if (results[i] != null) {
            return results[i];
        }
        return null;
    }
    /**
     * @param {?} parent
     * @param {?=} duration
     * @return {?}
     */
    expand(parent, duration = 200) {
        if (this.data[parent].content) {
            this.data[parent].content.scrollToPoint(0, 0, duration);
        }
        else {
            if (!this.data[parent].preserveHeader) {
                /** @type {?} */
                let names = [];
                for (let key in this.data) {
                    if (this.data[key].parent == parent)
                        names.push(key);
                }
                for (let name of names)
                    this.data[name].content.scrollToPoint(0, 0, duration);
            }
            else {
                /** @type {?} */
                let currentTab = this.findCurrentTab(parent);
                this.data[currentTab].content.scrollToPoint(0, 0, duration);
            }
        }
    }
    /**
     * @param {?} parent
     * @param {?=} duration
     * @return {?}
     */
    shrink(parent, duration = 200) {
        /** @type {?} */
        let height = parseInt(this.data[parent].header.nativeElement.parentNode.style.height, 10);
        if (height > this.data[parent].shrinkexpandheaderHeight) {
            if (this.data[parent].content) {
                this.data[parent].content.scrollToPoint(0, (this.data[parent].shrinkexpandHeight - this.data[parent].shrinkexpandheaderHeight), duration);
            }
            else {
                if (!this.data[parent].preserveHeader) {
                    /** @type {?} */
                    let names = [];
                    for (let key in this.data) {
                        if (this.data[key].parent == parent)
                            names.push(key);
                    }
                    for (let name of names) {
                        this.data[name].content.scrollToPoint(0, (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight), duration);
                    }
                }
                else {
                    /** @type {?} */
                    let currentTab = this.findCurrentTab(parent);
                    this.data[currentTab].content.scrollToPoint(0, (this.data[currentTab].shrinkexpandHeight - this.data[currentTab].shrinkexpandheaderHeight), duration);
                }
            }
        }
    }
    /**
     * @param {?} parent
     * @param {?=} duration
     * @return {?}
     */
    toggle(parent, duration = 200) {
        if (this.data[parent].content) {
            /** @type {?} */
            let height = parseInt(this.data[parent].header.nativeElement.parentNode.style.height, 10);
            if (height < this.data[parent].shrinkexpandHeight)
                this.data[parent].content.scrollToPoint(0, 0, duration);
            else
                this.data[parent].content.scrollToPoint(0, (this.data[parent].shrinkexpandHeight - this.data[parent].shrinkexpandheaderHeight), duration);
        }
        else {
            if (!this.data[parent].preserveHeader) {
                /** @type {?} */
                let names = [];
                for (let key in this.data) {
                    if (this.data[key].parent == parent)
                        names.push(key);
                }
                /** @type {?} */
                let height = parseInt(this.data[parent].header.nativeElement.parentNode.style.height, 10);
                for (let name of names) {
                    if (height < this.data[name].shrinkexpandHeight)
                        this.data[name].content.scrollToPoint(0, 0, duration);
                    else
                        this.data[name].content.scrollToPoint(0, (this.data[name].shrinkexpandHeight - this.data[name].shrinkexpandheaderHeight), duration);
                }
            }
            else {
                /** @type {?} */
                let currentTab = this.findCurrentTab(parent);
                /** @type {?} */
                let height = parseInt(this.data[parent].header.nativeElement.parentNode.style.height, 10);
                if (height < this.data[currentTab].shrinkexpandHeight)
                    this.data[currentTab].content.scrollToPoint(0, 0, duration);
                else
                    this.data[currentTab].content.scrollToPoint(0, (this.data[currentTab].shrinkexpandHeight - this.data[currentTab].shrinkexpandheaderHeight), duration);
            }
        }
    }
}
HidenavShService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
HidenavShService.ctorParameters = () => [];
/** @nocollapse */ HidenavShService.ngInjectableDef = defineInjectable({ factory: function HidenavShService_Factory() { return new HidenavShService(); }, token: HidenavShService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavStretchheaderComponent {
    /**
     * @param {?} el
     * @param {?} globals
     */
    constructor(el, globals) {
        this.el = el;
        this.globals = globals;
        this.scroll = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const observer = new MutationObserver((/**
         * @param {?} mutations
         * @return {?}
         */
        (mutations) => {
            mutations.forEach((/**
             * @return {?}
             */
            () => {
                if (this.el.nativeElement.getAttribute('hidenav-sh-header').length > 0) {
                    this.name = this.el.nativeElement.getAttribute('hidenav-sh-header');
                    this.start();
                    observer.disconnect();
                }
            }));
        }));
        observer.observe(this.el.nativeElement, {
            attributes: true,
        });
    }
    /**
     * @return {?}
     */
    start() {
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            this.globals.data[this.name].header = this.header;
            this.globals.data[this.name].static = this.static;
            this.globals.initiate(this.name);
            this.globals.scroll.subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => {
                if (res.name == this.name) {
                    this.scroll.emit(res.height);
                }
            }));
            if (this.noBorder != 'true') {
                /** @type {?} */
                let mode = document.querySelector('html').getAttribute('mode');
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (typeof this.class == 'undefined') {
                        this.class = mode;
                    }
                    else {
                        this.class += ' ' + mode;
                    }
                }), 0);
            }
        }
    }
    /**
     * @param {?=} duration
     * @return {?}
     */
    expand(duration = 200) {
        this.globals.expand(this.name, duration);
    }
    /**
     * @param {?=} duration
     * @return {?}
     */
    shrink(duration = 200) {
        this.globals.shrink(this.name, duration);
    }
    /**
     * @param {?=} duration
     * @return {?}
     */
    toggle(duration = 200) {
        this.globals.toggle(this.name, duration);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.name) {
            delete this.globals.data[this.name].header;
        }
    }
}
HidenavStretchheaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'hidenav-stretchheader',
                template: `
        <style>
            .overlay {
                position: absolute;
                height: inherit;
                width: inherit;
                z-index: 101;
                pointer-events: none;
                /*opacity: var(--opacity);*/
                background: var(--color);
                filter: opacity(0);
                --opacity: 0;
                --color: black;
            }

            :host {
                --blur: 0;
                z-index: 1;
            }

            :host.md {
                -webkit-box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.53);
                -moz-box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.53);
                box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.53);
            }

            :host.ios {
                border-bottom: 1px solid #5a5e63;
            }
        </style>
        <div class="overlay"></div>
        <ng-content></ng-content>
    `
            }] }
];
HidenavStretchheaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: HidenavShService }
];
HidenavStretchheaderComponent.propDecorators = {
    header: [{ type: ContentChild, args: ['shrinkexpand', { read: ElementRef },] }],
    static: [{ type: ContentChildren, args: ['static', { read: ElementRef },] }],
    class: [{ type: HostBinding, args: ['class',] }],
    noBorder: [{ type: Input, args: ['no-border',] }],
    headerHeight: [{ type: Input, args: ['header-height',] }],
    initExpanded: [{ type: Input, args: ['init-expanded',] }],
    opacityColor: [{ type: Input, args: ['opacity-color',] }],
    opacityFactor: [{ type: Input, args: ['opacity-factor',] }],
    blurFactor: [{ type: Input, args: ['blur-factor',] }],
    preserveHeader: [{ type: Input, args: ['preserve-header',] }],
    scroll: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavShContentDirective {
    /**
     * @param {?} el
     * @param {?} contentElem
     * @param {?} globals
     */
    constructor(el, contentElem, globals) {
        this.el = el;
        this.contentElem = contentElem;
        this.globals = globals;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.contentElem.nativeElement.hasAttribute('hidenav-tabspage')) {
            this.name = this.globals.requestName();
            $(this.contentElem.nativeElement).attr('hidenav-sh-content', this.name);
            $('hidenav-stretchheader', $(this.contentElem.nativeElement).parents().get().find((/**
             * @param {?} itm
             * @return {?}
             */
            itm => $(itm).find('[hidenav-header]').length))).attr('hidenav-sh-header', this.name);
            this.start();
        }
        else {
            /** @type {?} */
            let counter = 0;
            /** @type {?} */
            let int = setInterval((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                let x = $(this.contentElem.nativeElement).closest('[hidenav-sh-tabscontent]').attr('hidenav-sh-tabscontent');
                counter++;
                if (x && x.length > 0) {
                    this.parent = $(this.contentElem.nativeElement).closest('[hidenav-sh-tabscontent]').attr('hidenav-sh-tabscontent');
                    this.name = this.globals.requestTabName(this.parent);
                    $(this.contentElem.nativeElement).attr('hidenav-sh-content', this.name);
                    $(this.contentElem.nativeElement).attr('hidenav-tabspage', this.parent);
                    this.start();
                    clearInterval(int);
                }
                else if (counter > 50) {
                    clearInterval(int);
                }
            }), 50);
        }
    }
    /**
     * @return {?}
     */
    start() {
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            this.globals.data[this.name].content = this.el;
            this.globals.data[this.name].contentEl = this.contentElem;
            if (this.parent)
                this.globals.data[this.name].parent = this.parent;
            this.globals.initiate(this.name);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.name) {
            delete this.globals.data[this.name].content;
        }
    }
}
HidenavShContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hidenav-sh-content]'
            },] }
];
HidenavShContentDirective.ctorParameters = () => [
    { type: IonContent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: ElementRef },
    { type: HidenavShService }
];
HidenavShContentDirective.propDecorators = {
    hntb: [{ type: Input, args: ['hidenav-tabspage',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavShTabscontentDirective {
    /**
     * @param {?} contentElem
     * @param {?} el
     * @param {?} globals
     */
    constructor(contentElem, el, globals) {
        this.contentElem = contentElem;
        this.el = el;
        this.globals = globals;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.name = this.globals.requestName();
        this.contentElem.nativeElement.setAttribute('hidenav-sh-tabscontent', this.name);
        $('hidenav-stretchheader', $(this.contentElem.nativeElement).parents().get().find((/**
         * @param {?} itm
         * @return {?}
         */
        itm => $(itm).find('[hidenav-stretchheader]').length))).attr('hidenav-sh-header', this.name);
        if (this.name) {
            if (typeof this.globals.data[this.name] == 'undefined' || this.globals.data[this.name] == null)
                this.globals.data[this.name] = [];
            this.globals.data[this.name].tabscontent = this.el;
            this.globals.data[this.name].tabscontentElem = this.contentElem;
            this.globals.data[this.name].supertabs = this.supertabs;
            this.globals.initiate(this.name);
            this.supertabs.tabChange.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            e => {
                /** @type {?} */
                let i = e.detail.index;
                /** @type {?} */
                let tabs = this.contentElem.nativeElement.querySelectorAll('super-tab');
                /** @type {?} */
                let results = [];
                for (let tab of tabs) {
                    /** @type {?} */
                    let cont = tab.querySelector('ion-content');
                    if (cont != null && typeof cont.attributes['hidenav-sh-content'] != 'undefined' && cont.attributes['hidenav-sh-content'].nodeValue != '')
                        results.push(cont.attributes['hidenav-sh-content'].nodeValue);
                    else
                        results.push(null);
                }
                if (results[i] != null) {
                    this.globals.resetContent(results[i]);
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        delete this.globals.data[this.name].tabscontent;
    }
}
HidenavShTabscontentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hidenav-sh-tabscontent]'
            },] }
];
HidenavShTabscontentDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IonContent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: HidenavShService }
];
HidenavShTabscontentDirective.propDecorators = {
    supertabs: [{ type: ContentChild, args: [SuperTabs,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HidenavModule {
}
HidenavModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    HidenavTabscontentDirective,
                    HidenavContentDirective,
                    HidenavHeaderDirective,
                    HidenavStretchheaderComponent,
                    HidenavShContentDirective,
                    HidenavShTabscontentDirective
                ],
                exports: [
                    HidenavTabscontentDirective,
                    HidenavContentDirective,
                    HidenavHeaderDirective,
                    HidenavStretchheaderComponent,
                    HidenavShContentDirective,
                    HidenavShTabscontentDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { HidenavModule, HidenavContentDirective, HidenavHeaderDirective, HidenavService, HidenavShContentDirective, HidenavShService, HidenavShTabscontentDirective, HidenavStretchheaderComponent, HidenavTabscontentDirective };

//# sourceMappingURL=ionic4-hidenav.js.map